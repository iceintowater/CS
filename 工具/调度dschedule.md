# dschedule

## 组成
调度中心、执行器、job

### 调度中心

1、自研调度模块
2、日志回调模块
3、注册模块

### 执行器

 执行器实际上是一个内嵌的Server，默认端口9999（配置项：xxl.job.executor.port）。
在项目启动时，执行器会通过“@JobHandler”识别Spring容器中“Bean模式任务”，以注解的value属性为key管理起来。
“执行器”接收到“调度中心”的调度请求时，如果任务类型为“Bean模式”，将会匹配Spring容器中的“Bean模式任务”，然后调用其execute方法，执行任务逻辑。

### job

”Bean模式”
开发步骤： 每个Bean模式任务都是一个Spring的Bean类实例，它被维护在“执行器”项目的Spring容器中。任务类需要加“@JobHandler(value=“名称”)”注解，因为“执行器”会根据该注解识别Spring容器中的任务。任务类需要继承统一接口“IJobHandler”，任务逻辑在execute方法中开发，因为“执行器”在接收到调度中心的调度请求时，将会调用“IJobHandler”的execute方法，执行任务逻辑

## 过程  
一次完整的任务调度通讯流程  
- -1、任务触发，匹配执行器，加载在线的执行器
- 0、根据不同的路由策略选中执行器
- 1、“调度中心”向“执行器”发送http调度请求: “执行器”中接收请求的服务，实际上是一台内嵌Server;
- 2、“执行器”执行任务逻辑；
- 3、“执行器”http回调“调度中心”调度结果: “调度中心”中接收回调的服务，是针对执行器开放一套API服务;

### 路由策略  
执行器集群部署时提供丰富的路由策略，包括：第一个、最后一个、轮询、随机、一致性HASH、最不经常使用、最近最久未使用、故障转移、忙碌转移等；
第一个、最后一个、轮询、随机：都是简单读address_list即可
一致性HASH：TreeSet实现一致性hash算法
最不经常使用、最近最久未使用：HashMap、LinkedHashMap
故障转移：遍历address_list获取address时，逐个检查该address的心跳（请求返回状态）；只有心跳正常的address才返回使用
忙碌转移：遍历address_list获取address时，逐个检查该address是否忙碌（请求返回状态）；只有状态为idle的address才返回使用

## 特性

1、子任务  
XXL-JOB中每个任务都对应有一个任务ID，同时，每个任务支持设置属性“子任务ID”，因此，通过“任务ID”可以匹配任务依赖关系。
当父任务执行结束并且执行成功时，将会根据“子任务ID”匹配子任务依赖，如果匹配到子任务，将会主动触发一次子任务的执行。
在任务日志界面，点击任务的“执行备注”的“查看”按钮，可以看到匹配子任务以及触发子任务执行的日志信息，如无信息则表示未触发子任务执行。

2、切片  
执行器集群部署时，任务路由策略选择”分片广播"情况下，一次任务调度将会广播触发对应集群中所有执行器执行一次任务，同时系统自动传递分片参数；可根据分片参数开发分片任务；

## 集群

### 调度中心集群
调度中心支持集群部署，提升调度系统容灾和可用性  
调度中心集群部署时，几点要求和建议：  
DB配置保持一致；  
登陆账号配置保持一致；  
集群机器时钟保持一致（单机集群忽视）  
建议：推荐通过nginx为调度中心集群做负载均衡，分配域名。调度中心访问、执行器回调配置、调用API服务等操作均通过该域名进行。   
基于数据库的集群方案，数据库选用Mysql；  
集群分布式并发环境中进行定时任务调度时，会在各个节点会上报任务，存到数据库中，执行时会从数据库中取出触发器来执行，如果触发器的名称和执行时间相同，则只有一个节点去执行此任务。

### 执行器集群
执行器支持集群部署，提升调度系统可用性，同时提升任务处理能力。  
执行器集群部署时，几点要求和建议：  
执行器回调地址（xxl.job.admin.addresses）需要保持一致；执行器根据该配置进行执行器自动注册等操作  
同一个执行器集群内AppName（xxl.job.executor.appname）需要保持一致；调度中心根据该配置动态发现不同集群的在线执行器列表。  
  &nbsp;&nbsp;&nbsp;&nbsp;执行器如若集群部署，调度中心将会感知到在线的所有执行器，如“127.0.0.1:9997, 127.0.0.1:9998, 127.0.0.1:9999”。  
当任务”路由策略"选择"故障转移(FAILOVER)"时，当调度中心每次发起调度请求时，会按照顺序对执行器发出心跳检测请求，第一个检测为存活状态的执行器将会被选定并发送调度请求。  

## 原理  
定时执行任务逻辑：  
定时任务scheduleThread：不断从db把5秒内要执行的任务读出，立即触发 / 放到时间轮等待触发，并更新trigger_next_time  
      1、获取当前时间now  
      2、轮询db，找出trigger_next_time在距now 5秒内的任务，放入时间片中  
if  对到达now时间后的任务（nextrigertime+5s<now ）：  
直接跳过不执行；  
重置trigger_next_time  
else  对到达now时间后的任务（nextrigertime<now）：  
         重置trigger_next_time  
        if(now+5>nextrigertime+5s>now)  
则放到时间轮内（Map<Integer, List<Integer>> 秒数(1-60) => 任务id列表）；  
重置trigger_next_time  
（2）对未到达now时间的任务：  
直接放到时间轮内；  
重置trigger_next_time  
定时任务ringThread：时间轮实现到点触发任务  
时间轮数据结构：Map<Integer, List<Integer>> key是秒数(1-60) ，value是任务id列表  
1获取当前时间秒数  
2从时间轮内移出当前秒数前2个秒数（避免处理耗时太长，跨过刻度，向前校验一个刻度）的任务列表id，一一触发任务；  
